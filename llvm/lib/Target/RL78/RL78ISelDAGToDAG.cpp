//===-- RL78ISelDAGToDAG.cpp - A dag to dag inst selector for RL78 ------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the RL78 target.
//
//===----------------------------------------------------------------------===//

#include "RL78TargetMachine.h"
#include "llvm/CodeGen/SelectionDAGISel.h"

using namespace llvm;

//===----------------------------------------------------------------------===//
// Instruction Selector Implementation
//===----------------------------------------------------------------------===//

//===--------------------------------------------------------------------===//
/// RL78DAGToDAGISel - RL78 specific code to select RL78 machine
/// instructions for SelectionDAG operations.
///
namespace {
class RL78DAGToDAGISel : public SelectionDAGISel {
  /// Subtarget - Keep a pointer to the RL78 Subtarget around so that we can
  /// make the right decision when generating code for different targets.
  const RL78Subtarget *Subtarget = nullptr;

  void MatchSET1CLR1(SDNode *&N);
  SDNode *SelectFI(SDNode *N);

public:
  explicit RL78DAGToDAGISel(RL78TargetMachine &tm) : SelectionDAGISel(tm) {}

  bool runOnMachineFunction(MachineFunction &MF) override {
    Subtarget = &MF.getSubtarget<RL78Subtarget>();
    return SelectionDAGISel::runOnMachineFunction(MF);
  }

  void PostprocessISelDAG() override;

  void Select(SDNode *N) override;
  // Complex Pattern Selectors.
  bool SelectADDRr(SDValue Addr, SDValue &Base);
  bool SelectADDRrr(SDValue Addr, SDValue &R1, SDValue &R2);
  bool SelectADDRSPi(SDValue Addr, SDValue &Base, SDValue &Offset);

  template <int Max>
  bool SelectADDRri(SDValue Addr, SDValue &Base, SDValue &Offset) {
    return SelectADDRri(Addr, Max, Base, Offset);
  }
  bool SelectADDRri(SDValue Addr, unsigned Size, SDValue &Base,
                    SDValue &Offset);

  bool SelectADDRABS16(SDValue Addr, SDValue &Base);
  bool SelectSaddr(SDValue Addr, SDValue &Base);
  bool SelectADDRESABS16(SDValue Addr, SDValue &BaseHi, SDValue &BaseLow);
  bool SelectADDRESri(SDValue Addr, SDValue &BaseHi, SDValue &BaseLow,
                      SDValue &Offset);
  bool SelectADDRESr(SDValue Addr, SDValue &BaseHi, SDValue &BaseLow);

  /// SelectInlineAsmMemoryOperand - Implement addressing mode selection for
  /// inline asm expressions.
  bool SelectInlineAsmMemoryOperand(const SDValue &Op, unsigned ConstraintID,
                                    std::vector<SDValue> &OutOps) override;

  StringRef getPassName() const override {
    return "RL78 DAG->DAG Pattern Instruction Selection";
  }

  // FIXME: we can preprocess/postprocess the DAG

  // Include the pieces autogenerated from the target description.
#include "RL78GenDAGISel.inc"
};
} // end anonymous namespace

static SDValue TraversePossibleMOV(SDValue Value) {
  if (Value.isMachineOpcode() &&
      (Value.getMachineOpcode() == RL78::MOV_r_imm ||
       Value.getMachineOpcode() == RL78::MOVW_rp_imm))
    return Value.getOperand(0);
  // TODO: are there any other, cmp related cases that we need to handle?
  return Value;
}

static bool AreCmpOpsEqual(SDValue Cmp) {
  // Avoid matching cmp_r_memri  t41, t41, ...
  // see gcc.c_torture\pr33870.c -O1
  if (Cmp.getMachineOpcode() != RL78::CMPW_rp_imm &&
      Cmp.getMachineOpcode() != RL78::CMPW_rp_rp &&
      Cmp.getMachineOpcode() != RL78::CMP_r_imm &&
      Cmp.getMachineOpcode() != RL78::CMP_r_r)
    return false;

  SDValue LHS = Cmp.getOperand(0);
  SDValue RHS = Cmp.getOperand(1);
  return TraversePossibleMOV(LHS) == TraversePossibleMOV(RHS);
}

void RL78DAGToDAGISel::PostprocessISelDAG() {
  SelectionDAG::allnodes_iterator Position = CurDAG->allnodes_end();

  bool MadeChange = false;
  while (Position != CurDAG->allnodes_begin()) {
    SDNode *N = &*--Position;
    // Skip dead nodes and any non-machine opcodes.
    if (N->use_empty() || !N->isMachineOpcode())
      continue;

    // Eliminate cmp(w) ax, ax
    //           selectcc ...
    // Assume that N->getOperand(3).getMachineOpcode() == CMP_*.
    if ((N->getMachineOpcode() == RL78::SELECTCC16 ||
         N->getMachineOpcode() == RL78::SELECTCC8) &&
        AreCmpOpsEqual(N->getOperand(3))) {

      SDValue SelectionResult;
      SDValue TrueValue = N->getOperand(0);
      SDValue FalseValue = N->getOperand(1);
      switch ((RL78CC::CondCodes)N->getConstantOperandVal(2)) {
      case RL78CC::RL78CC_C:
      case RL78CC::RL78CC_NZ:
      case RL78CC::RL78CC_H:
        SelectionResult = FalseValue;
        break;
      case RL78CC::RL78CC_NC:
      case RL78CC::RL78CC_NH:
      case RL78CC::RL78CC_Z:
        SelectionResult = TrueValue;
        break;
      default:
        assert(false && "Unexpected condition code!");
        break;
      }

      CurDAG->ReplaceAllUsesWith(N, &SelectionResult);
      MadeChange = true;
    } else if (N->getMachineOpcode() == RL78::BRCC &&
               AreCmpOpsEqual(N->getOperand(3))) {
      // see gcc.c_torture\scal-to-vec1.c. -O3
      switch ((RL78CC::CondCodes)N->getConstantOperandVal(1)) {
      case RL78CC::RL78CC_C:
      case RL78CC::RL78CC_NZ:
      case RL78CC::RL78CC_H:
        CurDAG->ReplaceAllUsesWith(N, &N->getOperand(2));
        break;
      case RL78CC::RL78CC_NC:
      case RL78CC::RL78CC_NH:
      case RL78CC::RL78CC_Z: {
        SDLoc dl(N);
        MachineSDNode *BranchNode =
            CurDAG->getMachineNode(RL78::BR, dl, N->getValueType(0),
                                   N->getOperand(0), N->getOperand(2));
        CurDAG->ReplaceAllUsesWith(N, BranchNode);
      } break;
      default:
        assert(false && "Unexpected condition code!");
        break;
      }
      MadeChange = true;
    }
  }
  if (MadeChange)
    CurDAG->RemoveDeadNodes();
}

bool RL78DAGToDAGISel::SelectADDRSPi(SDValue Addr, SDValue &Base,
                                     SDValue &Offset) {
  // Addr.dump(CurDAG);
  if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
    Base = CurDAG->getTargetFrameIndex(
        FIN->getIndex(), TLI->getPointerTy(CurDAG->getDataLayout()));
    Offset = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i16);
    return true;
  }
  if (Addr.getOpcode() == ISD::ADD || Addr.getOpcode() == ISD::OR) {
    if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1))) {
      if (isUInt<16>(CN->getZExtValue())) {
        if (FrameIndexSDNode *FIN =
                dyn_cast<FrameIndexSDNode>(Addr.getOperand(0))) {
          // Constant offset from frame ref.
          Base = CurDAG->getTargetFrameIndex(
              FIN->getIndex(), TLI->getPointerTy(CurDAG->getDataLayout()));
          Offset = CurDAG->getTargetConstant(CN->getZExtValue(), SDLoc(Addr),
                                             MVT::i16);
          return true;
        }
      }
    }
  }
  return false;
}

bool RL78DAGToDAGISel::SelectADDRr(SDValue Addr, SDValue &Base) {
  if (Addr.getOpcode() == RL78ISD::LOW16)
    return false;
  if (Addr.getOpcode() == RL78ISD::HI16)
    return false;
  if (Addr.getOpcode() == RL78ISD::LOW8)
    return false;
  if (Addr.getOpcode() == ISD::FrameIndex)
    return false;
  if (Addr.getOpcode() == ISD::TargetExternalSymbol ||
      Addr.getOpcode() == ISD::TargetGlobalAddress ||
      Addr.getOpcode() == ISD::TargetBlockAddress ||
      Addr.getOpcode() == ISD::TargetGlobalTLSAddress)
    return false; // Direct calls.
  Base = Addr;
  return true;
}

bool RL78DAGToDAGISel::SelectADDRri(SDValue Addr, unsigned Max, SDValue &Base,
                                    SDValue &Offset) {
  // Addr.dump(CurDAG);
  if (Addr.getOpcode() == RL78ISD::LOW16)
    return false;
  if (Addr.getOpcode() == RL78ISD::HI16)
    return false;
  if (Addr.getOpcode() == RL78ISD::LOW8)
    return false;
  if (Addr.getOpcode() == ISD::FrameIndex)
    return false;
  // TODO: do we need this?
  // if (Addr.getOpcode() == ISD::TargetFrameIndex) return false;
  if (Addr.getOpcode() == ISD::TargetExternalSymbol ||
      Addr.getOpcode() == ISD::TargetGlobalAddress ||
      Addr.getOpcode() == ISD::TargetBlockAddress ||
      Addr.getOpcode() == ISD::TargetGlobalTLSAddress)
    return false; // Direct calls.

  if (Addr.getOpcode() == ISD::ADD || Addr.getOpcode() == ISD::OR) {
    if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1))) {
      if (FrameIndexSDNode *FIN =
              dyn_cast<FrameIndexSDNode>(Addr.getOperand(0))) {
        return false;
      }
      if ((CN->getSExtValue() > 0) && (CN->getSExtValue() <= Max)) {
        Base = Addr.getOperand(0);
        Offset = CurDAG->getTargetConstant(CN->getZExtValue(), SDLoc(Addr),
                                           MVT::i16);
        return true;
      }
    }
    //
    else if (Addr.getOpcode() == ISD::ADD &&
             ((Addr.getOperand(1).getOpcode() == ISD::SIGN_EXTEND) ||
              (Addr.getOperand(1).getOpcode() == ISD::ZERO_EXTEND)))
      return false;
  }
  Base = Addr;
  Offset = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i16);
  return true;
}

bool RL78DAGToDAGISel::SelectADDRrr(SDValue Addr, SDValue &R1, SDValue &R2) {
  if (Addr.getOpcode() == RL78ISD::LOW16)
    return false;
  if (Addr.getOpcode() == RL78ISD::HI16)
    return false;
  if (Addr.getOpcode() == RL78ISD::LOW8)
    return false;
  if (Addr.getOpcode() == ISD::FrameIndex)
    return false;
  if (Addr.getOpcode() == ISD::TargetExternalSymbol ||
      Addr.getOpcode() == ISD::TargetGlobalAddress ||
      Addr.getOpcode() == ISD::TargetBlockAddress ||
      Addr.getOpcode() == ISD::TargetGlobalTLSAddress)
    return false; // direct calls.

  if (Addr.getOpcode() == ISD::ADD) {
    if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1)))
      return false;
    //
    if ((Addr.getOperand(1).getOpcode() != ISD::SIGN_EXTEND) &&
        (Addr.getOperand(1).getOpcode() != ISD::ZERO_EXTEND))
      return false;
    R1 = Addr.getOperand(0);
    R2 = Addr.getOperand(1)->getOperand(0);
    return true;
  }
  //
  return false;
}

bool RL78DAGToDAGISel::SelectADDRABS16(SDValue Addr, SDValue &Base) {
  if (Addr.getOpcode() == RL78ISD::LOW16 &&
      (Addr.getOperand(0).getOpcode() == ISD::TargetGlobalAddress ||
       Addr.getOperand(0).getOpcode() == ISD::Constant)) {
    Base = Addr->getOperand(0);
    return true;
  }

  if (Addr.getOpcode() == ISD::Constant) {
    Base = CurDAG->getTargetConstant(
        (dyn_cast<ConstantSDNode>(Addr)->getConstantIntValue()->getZExtValue()),
        SDLoc(Addr), MVT::i16);
    return true;
  }

  return false;
}

bool RL78DAGToDAGISel::SelectADDRESABS16(SDValue Addr, SDValue &BaseHi,
                                         SDValue &BaseLow) {
  // Addr.dump(CurDAG);
  if (Addr.getOpcode() != RL78ISD::HI16)
    return false;
  if ((Addr.getOperand(0).getOpcode() != ISD::TargetGlobalAddress) &&
      (Addr.getOperand(0).getOpcode() != ISD::Constant))
    return false;
  if (!SelectADDRABS16(Addr.getOperand(1), BaseLow))
    return false;
  if (Addr.getOperand(0).getOpcode() == ISD::Constant)
    BaseHi = CurDAG->getTargetConstant(Addr.getConstantOperandVal(0),
                                       SDLoc(Addr), MVT::i16);
  else
    BaseHi = Addr->getOperand(0);

  return true;
}

bool RL78DAGToDAGISel::SelectADDRESri(SDValue Addr, SDValue &BaseHi,
                                      SDValue &BaseLow, SDValue &Offset) {
  if (Addr.getOpcode() != RL78ISD::HI16 &&
      (Addr.getOpcode() != ISD::ADD ||
       Addr->getOperand(0).getOpcode() != RL78ISD::HI16))
    return false;
  if (Addr.getOpcode() == RL78ISD::LOW16)
    return false;
  if (Addr.getOpcode() == RL78ISD::LOW8)
    return false;
  if (Addr.getOpcode() == ISD::FrameIndex)
    return false;
  if (Addr.getOpcode() == ISD::TargetExternalSymbol ||
      Addr.getOpcode() == ISD::TargetGlobalAddress ||
      Addr.getOpcode() == ISD::TargetBlockAddress ||
      Addr.getOpcode() == ISD::TargetGlobalTLSAddress)
    return false;
  // Addr.dump();
  if (Addr.getOpcode() == ISD::ADD) {
    BaseHi = Addr->getOperand(0);
    BaseLow = Addr->getOperand(0)->getOperand(1);
    uint64_t op0Offset = 0;
    if (Addr->getOperand(0)->getNumOperands() > 2)
      op0Offset = Addr->getOperand(0)->getConstantOperandVal(2);
    Offset = CurDAG->getTargetConstant(
        Addr->getConstantOperandVal(1) + op0Offset, SDLoc(Addr), MVT::i16);
    return true;
  } else {
    BaseHi = Addr;
    BaseLow = Addr->getOperand(1);
  }

  if (Addr->getNumOperands() > 2)
    Offset = CurDAG->getTargetConstant(Addr->getConstantOperandVal(2),
                                       SDLoc(Addr), MVT::i16);
  else
    Offset = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i16);
  // Offset.dump();
  return true;
}

bool RL78DAGToDAGISel::SelectADDRESr(SDValue Addr, SDValue &BaseHi,
                                     SDValue &BaseLow) {
  if (Addr.getOpcode() != RL78ISD::HI16)
    return false;
  if ((Addr.getOperand(0).getOpcode() == ISD::TargetGlobalAddress) ||
      (Addr.getOperand(0).getOpcode() == ISD::Constant))
    return false;
  if (Addr->getNumOperands() > 2)
    return false;
  // Addr.dump();
  BaseHi = Addr;
  BaseLow = Addr->getOperand(1);
  return true;
}

bool RL78DAGToDAGISel::SelectSaddr(SDValue Addr, SDValue &Base) {
  if (Addr.getOpcode() != RL78ISD::LOW8)
    return false;
  Base = Addr->getOperand(0);
  return true;
}

// HARD REQUIREMENT:
// 11.1.8 Controlling the Output of Bit Manipulation Instructions [V1.04 or
// later] To output bit manipulation instructions without using intrinsic
// functions, satisfy all conditions shown below. (a) A constant value is
// assigned. (b) The value is assigned to a single-bit bit field of the
// charunsigned charsigned char_Bool type in the near area. (c) The bit field
// where the value is assigned is qualified with volatile.
void RL78DAGToDAGISel::MatchSET1CLR1(SDNode *&N) {
  //   LOAD  IMM
  //    \     /
  //     \   /
  //     AND/OR
  //       |
  //     STORE
  const SDValue &logicalOp = N->getOperand(1);
  if ((logicalOp->getOpcode() != ISD::AND) &&
      (logicalOp->getOpcode() != ISD::OR))
    return;
  EVT VT = logicalOp->getValueType(0);
  if ((VT != MVT::i8) && (VT != MVT::i16))
    return;
  // The logical op needs to have only one use.
  if (!logicalOp->hasOneUse())
    return;
  const SDValue &load = logicalOp->getOperand(0);

  if ((load->getOpcode() != ISD::LOAD))
    return;
  // Reducing the width of a volatile load is illegal.
  if (VT == MVT::i16) {
    LoadSDNode *LN = cast<LoadSDNode>(load);
    if (LN->isVolatile())
      return;
  }
  
  bool UseLoadChain = true;
  SDNode::use_iterator UI = load.getNode()->use_begin(),
                       UE = load.getNode()->use_end();
  while (UI != UE) {
    SDUse &Use = UI.getUse();
    if (Use.getUser() != N && Use.getUser() != logicalOp.getNode())
      UseLoadChain = false;
    ++UI;
  }
  const SDValue &chain =
      UseLoadChain ? load->getOperand(0) : N->getOperand(0);

  // The load and store need to use the same address.
  if (load->getOperand(1) != N->getOperand(2))
    return;
  // Check the constant node is power of 2.
  if (!isa<ConstantSDNode>(logicalOp->getOperand(1)))
    return;
  uint64_t imm = logicalOp->getConstantOperandVal(1);
  if (logicalOp->getOpcode() == ISD::AND)
    imm = ~imm & 0xFF;
  if (!isPowerOf2_64(imm))
    return;
  // Make sure we can select.
  SDValue memOp = N->getOperand(2);
  if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(memOp)) {
    SDNode *MFIN = SelectFI(FIN);
    memOp = SDValue(MFIN, 0);
  }
  if ((memOp->getOpcode() == RL78ISD::HI16) && (memOp->getNumOperands() > 2)) {
    // FIXME: we can do an ADD + SET1/CLR1.
    return;
  }
  if (VT == MVT::i16) {
    // FIXME: Instead of return we can do an optimization here
    // (setTargetDAGCombine?!): imm >>= 8 and modify memOp to point at
    // address+1.
    if (imm & 0xFF00)
      return;
    VT = MVT::i8;
  }
  SDLoc dl(N);
  SDValue constVal = CurDAG->getConstant(Log2_64(imm), dl, VT);
  RL78ISD::NodeType opcode =
      (logicalOp->getOpcode() == ISD::AND) ? RL78ISD::CLR1 : RL78ISD::SET1;
  SDValue set1 = CurDAG->getNode(
      opcode, dl, MVT::Other, chain, constVal, memOp);
  // Update DAG.
  CurDAG->ReplaceAllUsesWith(N, &set1);
  CurDAG->RemoveDeadNodes();
  N = set1.getNode();
  return;
}

SDNode *RL78DAGToDAGISel::SelectFI(SDNode *N) {
  SDLoc DL(N);
  // N->dump();
  int FI = cast<FrameIndexSDNode>(N)->getIndex();
  EVT VT = N->getValueType(0);
  SDValue TFI = CurDAG->getTargetFrameIndex(FI, VT);
  // CurDAG->dump();
  unsigned Opc = RL78::MOVW_rp_stack_slot;
  SDValue Imm = CurDAG->getTargetConstant(0, DL, MVT::i16);
  if (N->hasOneUse()) {
    return CurDAG->SelectNodeTo(N, Opc, VT, TFI, Imm);
  } else {
    SDNode *MN = CurDAG->getMachineNode(Opc, DL, VT, TFI, Imm);
    ReplaceNode(N, MN);
    return MN;
  }
  // CurDAG->dump();
}

void RL78DAGToDAGISel::Select(SDNode *N) {
  SDLoc dl(N);
  if (N->isMachineOpcode()) {
    N->setNodeId(-1);
    return; // Already selected.
  }
  // N->dump(CurDAG);
  switch (N->getOpcode()) {
  default:
    break;
  case ISD::STORE:
    MatchSET1CLR1(N);
    break;
  case ISD::FrameIndex: {
    SelectFI(N);
    return;
  }
  case ISD::SHL: {
    // SHLW AX, 1 is 2 bytes, we can replace it with ADDW AX, AX (1 byte)
    if (N->getOperand(1).getOpcode() == ISD::Constant &&
        N->getConstantOperandVal(1) == 1 && N->getValueType(0) == MVT::i16) {
      SDLoc DL(N);
      EVT VT = MVT::i16;
      unsigned Opc = RL78::ADDW_rp_rp;
      SDNode *MN = CurDAG->getMachineNode(Opc, DL, VT, N->getOperand(0),
                                          N->getOperand(0));
      ReplaceNode(N, MN);
      return;
    }
    break;
  }
  case ISD::BUILD_PAIR: {
    SDLoc DL(N);
    if (N->getValueType(0) == MVT::i16) {
      SDValue RC, SubReg0, SubReg1;
      RC = CurDAG->getTargetConstant(RL78::RL78RPRegsRegClassID, DL, MVT::i16);
      SubReg0 = CurDAG->getTargetConstant(RL78::sub_lo, DL, MVT::i16);
      SubReg1 = CurDAG->getTargetConstant(RL78::sub_hi, DL, MVT::i16);
      const SDValue Ops[] = {RC, N->getOperand(0), SubReg0, N->getOperand(1),
                             SubReg1};
      ReplaceNode(N, CurDAG->getMachineNode(TargetOpcode::REG_SEQUENCE, DL,
                                            N->getValueType(0), Ops));
      return;
    } else {
      llvm_unreachable("Unhandled value type for BUILD_PAIR");
    }
    break;
  }
  case ISD::INLINEASM: {
    break;
  }
  }
  // N->dump(CurDAG);
  SelectCode(N);
}

/// SelectInlineAsmMemoryOperand - Implement addressing mode selection for
/// inline asm expressions.
bool RL78DAGToDAGISel::SelectInlineAsmMemoryOperand(
    const SDValue &Op, unsigned ConstraintID, std::vector<SDValue> &OutOps) {
  SDValue Op0, Op1;
  switch (ConstraintID) {
  default:
    return true;
    // TODO: specializations (m should allow all of them).
  case InlineAsm::Constraint_m: // Memory.
    if (SelectADDRrr(Op, Op0, Op1) || SelectADDRri(Op, 256, Op0, Op1)) {
      OutOps.push_back(Op0);
      OutOps.push_back(Op1);
      return false;
    } else if (SelectADDRr(Op, Op0)) {
      OutOps.push_back(Op0);
      return false;
    } else if (Op.getOpcode() == RL78ISD::LOW16) {
      OutOps.push_back(Op);
      return false;
    } else if (Op.getOpcode() == ISD::FrameIndex) {
      OutOps.push_back(Op);
      return false;
    }
    break;
  }

  return true;
}

/// createRL78ISelDag - This pass converts a legalized DAG into a
/// RL78-specific DAG, ready for instruction scheduling.
///
FunctionPass *llvm::createRL78ISelDag(RL78TargetMachine &TM) {
  return new RL78DAGToDAGISel(TM);
}
